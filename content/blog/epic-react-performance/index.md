---
title: React Performance
date: '2020-12-05'
---

![performance](./peformance.jpg)

Performance you say? does it even matter considering that by nature React is quite fast? Regardless, there are still things we can do to optimize our react applications with the following principles.

### Code Splitting

It is a way to improve performance with the principle that by loading less code that our apps will speed up.

If we have an application that uses heavy D3 code and users complain about how slow the app loads at login, we could say load the chart generated by the D3 code on demand instead.

There already is a method available for us from javascript, which is called the **dynamic import**

```javascript
import('/some-module.js').then(
  (module) => {
    // do stuff with the module's exports
  },
  (error) => {
    // there was some error loading the module...
  }
);
```

In React, such feature is made possible by **<React.Suspense/>**

An example:

```javascript
// smiley-face.js
import * as React from 'react';

function SmileyFace() {
  return <div>ðŸ˜ƒ</div>;
}

export default SmileyFace;

// app.js
import * as React from 'react';

const SmileyFace = React.lazy(() => import('./smiley-face'));

function App() {
  return (
    <div>
      <React.Suspense fallback={<div>loading...</div>}>
        <SmileyFace />
      </React.Suspense>
    </div>
  );
}
```

### useMemo for Expensive Calculations

### React.memo for Reducing re-renders

### Window Large Lists with react-virtual

### Optimize Context Value

### Fix Perf Death by a Thousand Cuts

### Production Performance Monitoring

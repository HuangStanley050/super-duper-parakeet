---
title: React Performance
date: '2020-12-05'
---

![performance](./peformance.jpg)

Performance you say? does it even matter considering that by nature React is quite fast? Regardless, there are still things we can do to optimize our react applications with the following principles.

### Code Splitting

It is a way to improve performance with the principle that by loading less code that our apps will speed up.

If we have an application that uses heavy D3 code and users complain about how slow the app loads at login, we could say load the chart generated by the D3 code on demand instead.

There already is a method available for us from javascript, which is called the **dynamic import**

```javascript
import('/some-module.js').then(
  (module) => {
    // do stuff with the module's exports
  },
  (error) => {
    // there was some error loading the module...
  }
);
```

In React, such feature is made possible by **<React.Suspense/>**

An example:

```javascript
// smiley-face.js
import * as React from 'react';

function SmileyFace() {
  return <div>ðŸ˜ƒ</div>;
}

export default SmileyFace;

// app.js
import * as React from 'react';

const SmileyFace = React.lazy(() => import('./smiley-face'));

function App() {
  return (
    <div>
      <React.Suspense fallback={<div>loading...</div>}>
        <SmileyFace />
      </React.Suspense>
    </div>
  );
}
```

### useMemo for Expensive Calculations

Since the introduction of react hooks, things have become quite easy especially with state management and logic all being all placed inside a functional component, which allows for awesome composability. This is equivalent to the render method in the react class component.

However with that, it comes with a cost.

In some sort of calculations function like below **render** will be performed every single time, regardless of whether the inputs for the calculations change.

Example:

```jsx
function Distance({x, y}) {
  const distance = calculateDistance(x, y)
  return (
    <div>
      The distance between {x} and {y} is {distance}.
    </div>
  )
}
```

> If that component's parent re-renders, or if we add some unrelated state to the component and trigger a re-render, we'll be calling `calculateDistance` every render which could lead to a performance bottleneck.

### React.memo for Reducing re-renders

### Window Large Lists with react-virtual

### Optimize Context Value

### Fix Perf Death by a Thousand Cuts

### Production Performance Monitoring

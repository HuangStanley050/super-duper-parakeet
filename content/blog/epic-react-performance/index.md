---
title: React Performance
date: '2020-12-05'
---

![performance](./peformance.jpg)

Performance you say? does it even matter considering that by nature React is quite fast? Regardless, there are still things we can do to optimize our react applications with the following principles.

### Code Splitting

It is a way to improve performance with the principle that by loading less code that our apps will speed up.

If we have an application that uses heavy D3 code and users complain about how slow the app loads at login, we could say load the chart generated by the D3 code on demand instead.

There already is a method available for us from javascript, which is called the **dynamic import**

```javascript
import('/some-module.js').then(
  module => {
    // do stuff with the module's exports
  },
  error => {
    // there was some error loading the module...
  }
);
```

In React, such feature is made possible by **<React.Suspense/>**

An example:

```javascript
// smiley-face.js
import * as React from 'react';

function SmileyFace() {
  return <div>ðŸ˜ƒ</div>;
}

export default SmileyFace;

// app.js
import * as React from 'react';

const SmileyFace = React.lazy(() => import('./smiley-face'));

function App() {
  return (
    <div>
      <React.Suspense fallback={<div>loading...</div>}>
        <SmileyFace />
      </React.Suspense>
    </div>
  );
}
```

### useMemo for Expensive Calculations

Since the introduction of react hooks, things have become quite easy especially with state management and logic all being all placed inside a functional component, which allows for awesome composability. This is equivalent to the render method in the react class component.

However with that, it comes with a cost.

In some sort of calculations function like below **render** will be performed every single time, regardless of whether the inputs for the calculations change.

Example:

```javascript
function Distance({ x, y }) {
  const distance = calculateDistance(x, y);
  return (
    <div>
      The distance between {x} and {y} is {distance}.
    </div>
  );
}
```

> If that component's parent re-renders, or if we add some unrelated state to the component and trigger a re-render, we'll be calling `calculateDistance` every render which could lead to a performance bottleneck.

**useMemo** can help with this particular use case:

```javascript
function Distance({ x, y }) {
  const distance = React.useMemo(() => calculateDistance(x, y), [x, y]);
  return (
    <div>
      The distance between {x} and {y} is {distance}.
    </div>
  );
}
```

> This allows us to put that calculation behind a function which is only called when the result actually needs to be re-evaluated (when the dependencies change). In the example above the array `[x, y]` are called "dependencies" and React knows that so long as those do not change, the result of our function will be the same as the last time the function was called.

### React.memo for Reducing re-renders

Summary of a react app life cycle:

```
â†’  render â†’ reconciliation â†’ commit
         â†–                   â†™
              state change
```

1. The "render" phase: create React elements React.createElement
2. The "reconciliation" phase: compare previous elements with the new ones
3. The "commit" phase: update the DOM (if needed).

**A React Component can re-render for any of the following reasons:**

1. Its props change
2. Its internal state changes
3. It is consuming context values which have changed
4. Its parent re-renders

> React is really fast, however, _sometimes_ it can be useful to give React little tips about certain parts of the React tree when there's a state update. You can opt-out of state updates for a part of the React tree by using one of React's built-in rendering bail-out utilities: `React.PureComponent`, `React.memo`, or `shouldComponentUpdate`.

Here is an example:

```javascript
function CountButton({ count, onClick }) {
  return <button onClick={onClick}>{count}</button>;
}

function NameInput({ name, onNameChange }) {
  return (
    <label>
      Name: <input value={name} onChange={e => onNameChange(e.target.value)} />
    </label>
  );
}

function Example() {
  const [name, setName] = React.useState('');
  const [count, setCount] = React.useState(0);
  const increment = () => setCount(c => c + 1);
  return (
    <div>
      <div>
        <CountButton count={count} onClick={increment} />
      </div>
      <div>
        <NameInput name={name} onNameChange={setName} />
      </div>
      {name ? <div>{`${name}'s favorite number is ${count}`}</div> : null}
    </div>
  );
}
```

> Based on how this is implemented, when you click on the counter button, the `<CountButton />` re-renders (so we can update the `count` value). But the `<NameInput />` is also re-rendered. If you have `Record why each component rendered while profiling.` enabled in React DevTools, then you'll see that under "Why did this render?" it says "The parent component rendered."

> React does this because it has no way of knowing whether the NameInput will need to return different React elements based on the state change of its parent. In our case there were no changes necessary, so React didn't bother updating the DOM. This is what's called an "unnecessary rerender" and if that render/reconciliation process is expensive, then it can be worthwhile to prevent it.

What we can provide React to stop the re render is one of two things from the API:

1. React.PureComponent: For class component

2. React.memo: For functional component

What they do is not they will prevent re render if its parent re-rendered thus improving performance if it's intended.

**Improving our example above**

```javascript
function CountButton({ count, onClick }) {
  return <button onClick={onClick}>{count}</button>;
}
CountButton = React.memo(CountButton);

function NameInput({ name, onNameChange }) {
  return (
    <label>
      Name: <input value={name} onChange={e => onNameChange(e.target.value)} />
    </label>
  );
}
NameInput = React.memo(NameInput);

// etc... no other changes necessary
```

### Window Large Lists with react-virtual

### Optimize Context Value

### Fix Perf Death by a Thousand Cuts

### Production Performance Monitoring
